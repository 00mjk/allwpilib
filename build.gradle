import org.apache.tools.ant.taskdefs.condition.Os

if (!project.hasProperty('skipJava')) {
apply plugin: 'java'
}
apply plugin: 'cpp'
apply plugin: 'visual-studio'

def generatedJNIHeaderLoc = 'build/include'

def platformSpecificIncludeFlag(loc, cppCompiler) {
  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
    cppCompiler.args "/I$loc"
  } else {
    cppCompiler.args '-I', loc
  }
}

model {
  toolChains {
    gcc(Gcc) {
      target("arm"){
        // We use a custom-built cross compiler with the prefix arm-frc-linux-gnueabi-<util name>
        // If this ever changes, the prefix will need to be changed here
        def compilerPrefix = 'arm-frc-linux-gnueabi-'
        cppCompiler.executable = compilerPrefix + cppCompiler.executable
        linker.executable = compilerPrefix + linker.executable
        assembler.executable = compilerPrefix + assembler.executable
        // Gradle auto-adds the -m32 argument to the linker and compiler. Our compiler only supports
        // arm, and doesn't understand this flag, so it is removed from both
        cppCompiler.withArguments { args ->
          args << '-std=c++1y' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
          args << '-Wno-psabi' << '-Wno-unused-parameter' << '-fPIC' << '-O0' << '-g3' << '-rdynamic'
          //TODO: When the compiler allows us to actually call deprecated functions from within
          // deprecated function, remove this line (this will cause calling deprecated functions
          // to be treated as a warning rather than an error).
          args << '-Wno-error=deprecated-declarations'
          args.remove('-m32')
        }
        linker.withArguments { args ->
          args << '-rdynamic'
          args.remove('-m32')
        }
        staticLibArchiver.executable = compilerPrefix + staticLibArchiver.executable
      }
      target('x86') {
        cppCompiler.withArguments { args ->
          args << '-std=c++11' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
          args << '-Wno-psabi' << '-Wno-unused-parameter' << '-fPIC' << '-O0' << '-g3' << '-rdynamic'
          //TODO: When the compiler allows us to actually call deprecated functions from within
          // deprecated function, remove this line (this will cause calling deprecated functions
          // to be treated as a warning rather than an error).
          args << '-Wno-error=deprecated-declarations'
          args << '-m32'
        }
        linker.withArguments { args ->
          args << '-rdynamic'
          args << '-m32'
        }
      }
      target('x64') {
        cppCompiler.withArguments { args ->
          args << '-std=c++11' << '-Wformat=2' << '-Wall' << '-Wextra' << '-Werror' << '-pedantic'
          args << '-Wno-psabi' << '-Wno-unused-parameter' << '-fPIC' << '-O0' << '-g3' << '-rdynamic'
          //TODO: When the compiler allows us to actually call deprecated functions from within
          // deprecated function, remove this line (this will cause calling deprecated functions
          // to be treated as a warning rather than an error).
          args << '-Wno-error=deprecated-declarations'
        }
        linker.withArguments { args ->
          args << '-rdynamic'
        }
      }
    }
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
      visualCpp(VisualCpp) {
        def vs14Dir = file('C:\\Program Files (x86)\\Microsoft Visual Studio 14.0')
        // If vs2015 is installed, fall back to vs2013 for now, until Gradle pulls in the right
        // includes for the win10 sdk.
        if (vs14Dir.exists()) {
          def vs12Dir = file('C:\\Program Files (x86)\\Microsoft Visual Studio 12.0')
          if (!vs12Dir.exists()) {
            throw new GradleException('Compilation with VS 2015 is not currently supported by Gradle. Please install VS 2013, or use the CMake build option.')
          }
          installDir = vs12Dir
        }
        eachPlatform {
          cppCompiler.withArguments { args ->
            args << '/EHsc' << '/DNOMINMAX' << '/D_SCL_SECURE_NO_WARNINGS' << '/D_WINSOCK_DEPRECATED_NO_WARNINGS'
          }
          linker.withArguments { args ->
            args << '/DEF:ntcore.def'
          }
        }
      }
    }
  }

  platforms {
    arm {
      architecture "arm"
      operatingSystem 'linux'
    }
    x86 {
      architecture "x86"
    }
    x64 {
      architecture "x86_64"
    }
  }

  components {
    ntcore(NativeLibrarySpec) {
      targetPlatform 'arm'
      targetPlatform 'x86'
      targetPlatform 'x64'
      binaries.all {
        tasks.withType(CppCompile) {


          if (!project.hasProperty('skipJava')) {
            if (targetPlatform == platforms.arm) {
              // ARM JDK is included for jni.h. We also need the arm-linux specific headers.
              // This does not need to change when compiling on Windows
              // The JNI headers are put into the build/include directory by the jniHeaders task
              sources {
                arm(CppSourceSet) {
                  source {
                    includes "java/arm-linux"
                    includes "java/arm-linux/linux"
                  }
                }
              }
            } else {
              def jdkLocation = org.gradle.internal.jvm.Jvm.current().javaHome
              platformSpecificIncludeFlag("${jdkLocation}/include", cppCompiler)

              if (targetPlatform.operatingSystem.macOsX) {
                platformSpecificIncludeFlag("${jdkLocation}/include/darwin", cppCompiler)
              } else if (targetPlatform.operatingSystem.linux) {
                platformSpecificIncludeFlag("${jdkLocation}/include/linux", cppCompiler)
              } else if (targetPlatform.operatingSystem.windows) {
                platformSpecificIncludeFlag("${jdkLocation}/include/win32", cppCompiler)
              } else if (targetPlatform.operatingSystem.freeBSD) {
                platformSpecificIncludeFlag("${jdkLocation}/include/freebsd", cppCompiler)
              }
            }

            jniHeadersNetworkTables.outputs.files.each { file ->
              if (targetPlatform == platforms.arm) {
                cppCompiler.args '-I', file.getPath()
              } else {
                platformSpecificIncludeFlag(file.getPath(), cppCompiler)
              }
            }
            dependsOn jniHeadersNetworkTables
          }
        }
      }
      sources {
        cpp {
          source {
            srcDirs = ["src"]
            if (!project.hasProperty('skipJava')) {
              srcDirs "java/lib"
            }
            includes = ["**/*.cpp"]
          }
          exportedHeaders {
            srcDirs = ["include"]
            if (!project.hasProperty('skipJava')) {
              jniHeadersNetworkTables.outputs.files.each { file ->
                srcDirs file.getPath()
              }
            }
            includes = ["**/*.h"]
          }
        }
      }
    }
  }
}

if (!project.hasProperty('skipJava')) {

compileJava {
  options.compilerArgs << "-Xlint:unchecked"
}

sourceSets {
  main {
    java {
      srcDirs = ["java/src"]
    }
  }
}

jar {
  description = 'Generates NetworkTables jar, with the JNI shared libraries embedded'
  dependsOn { armNtcoreSharedLibrary }
  dependsOn { x64NtcoreSharedLibrary }
  dependsOn { x86NtcoreSharedLibrary }
  dependsOn { classes }
  binaries.withType(SharedLibraryBinary) { binary ->
    from(file(binary.sharedLibraryFile)) {
      if (binary.targetPlatform == platforms.arm) {
        into "Linux/arm"
      } else if (binary.targetPlatform.operatingSystem.name == "Linux") {
        if (binary.targetPlatform.architecture.name == "x86-64") {
          into "Linux/amd64"
        } else {
          into "Linux/" + binary.targetPlatform.architecture.name
        }
      } else {
        into binary.targetPlatform.operatingSystem.name + "/" + binary.targetPlatform.architecture.name
      }
    }
  }
}

task networktablesJavaSource(type: Jar, dependsOn: classes) {
  description = 'Generates the source jar for NetworkTables java'
  group = 'WPILib'
  classifier = 'classes'
  from sourceSets.main.allJava
}

task networktablesJavadoc(type: Jar, dependsOn: javadoc) {
  description = 'Generates the javadoc jar for NetworkTables java'
  group = 'WPILib'
  classifier = 'javadoc'
  from javadoc.destinationDir
}

/**
 * Generates the JNI headers
 */
task jniHeadersNetworkTables {
  description = 'Generates JNI headers from edu.wpi.first.wpilibj.networktables.*'
  group = 'WPILib'
  def outputFolder = file(generatedJNIHeaderLoc)
  inputs.files sourceSets.main.output
  outputs.file outputFolder
  doLast {
    outputFolder.mkdirs()
    exec {
      executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
      args '-d', outputFolder
      args '-classpath', sourceSets.main.output.classesDir
      args 'edu.wpi.first.wpilibj.networktables.NetworkTablesJNI'
    }
  }
}

clean {
  delete generatedJNIHeaderLoc
}

}  // skipJava
