import org.gradle.internal.os.OperatingSystem

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.8'
    }
}

// Determine what repo to publish to. Default is development. Valid options are development, beta, stable, and release
if (!hasProperty('repo')) {
    allprojects {
        ext.repo = 'development'
    }
}

allprojects {
    repositories {
        mavenCentral()
        maven {
            url "${System.getProperty('user.home')}/releases/maven/${repo}"
        }
        maven {
            url "http://first.wpi.edu/FRC/roborio/maven/${repo}"
        }
    }
}

ext.buildArm = !project.hasProperty('skipArm')
ext.includeJava = !project.hasProperty('skipJava')

if (hasProperty('makeDesktop')) {
    println 'Making desktop classifier jar. NOTE: This desktop version should only be used for local testing.' +
            'It will only support the current platform, and will override fetching the latest development version from' +
            ' the maven repo until you manually delete it!'
}

ext.getPlatformPath2 = { targetPlatform ->
    if (targetPlatform.architecture.arm) {
        return 'Linux/arm'
    } else if (targetPlatform.operatingSystem.linux) {
        if (targetPlatform.architecture.amd64) {
            return 'Linux/amd64'
        } else {
            return 'Linux/' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.windows) {
        if (targetPlatform.architecture.amd64) {
            return 'Windows/amd64'
        } else {
            return 'Windows/' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.macOsX) {
        if (targetPlatform.architecture.amd64) {
            return 'Mac OS X/x86_64'
        } else {
            return 'Mac OS X/' + targetPlatform.architecture.name
        }
    } else {
        return targetPlatform.operatingSystem.name + '/' + targetPlatform.architecture.name
    }
}

ext.getPlatformPath = { binary ->
    return getPlatformPath2(binary.targetPlatform)
}

ext.useWpiUtil = { project ->
    def wpiUtilDependency =
        project.dependencies.create("edu.wpi.first.wpilib:wpiutil:1.0.0-SNAPSHOT:${project.isArm ? 'arm' : 'desktop'}@zip")
    def wpiUtilConfig = project.configurations.detachedConfiguration(wpiUtilDependency)
    wpiUtilConfig.setTransitive(false)
    def wpiUtil = wpiUtilConfig.files[0].canonicalFile
    def wpiUtilUnzipLocation = "${project.buildDir}/wpiutil"

    // Create a task that will unzip the wpiutil files into a temporary build directory
    project.tasks.create(name: "unzipWpiUtil", type: Copy) {
	description = 'Unzips the wpiutil maven dependency so that the include files and libraries can be used'
	group = 'WPILib'
	from zipTree(wpiUtil)
	into wpiUtilUnzipLocation
    }

    project.ext.wpiUtil = wpiUtilUnzipLocation
    project.ext.wpiUtilInclude = "$wpiUtilUnzipLocation/include"

    project.ext.addWpiUtilLibraryLinks = { compileTask, linker, targetPlatform ->
        compileTask.dependsOn "unzipWpiUtil"
        String path = project.getPlatformPath2(targetPlatform)
        if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.wpiUtil}/${path}/wpiutil.lib"
        } else {
            linker.args "${project.wpiUtil}/${path}/libwpiutil.a"
        }
    }
//    project.model {
//        repositories {
//            libwpiutil(PrebuiltLibraries) {
//                wpiutil {
//                    headers.srcDir "${project.wpiUtilUnzipLocation}/include"
//                    binaries.withType(StaticLibraryBinary) {
//                        staticLibraryFile = file("${project.wpiUtil}/libwpiutil.a")
//                    }
//                }
//            }
//        }
//    }
}

ext.getOpenCvPlatformPackage = { targetPlatform ->
    if (targetPlatform.architecture.arm) {
        return 'linux-arm'
    } else if (targetPlatform.operatingSystem.linux) {
        if (targetPlatform.architecture.amd64) {
            return 'linux-x86_64'
        } else {
            return 'linux-' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.windows) {
        if (targetPlatform.architecture.amd64) {
            return 'windows-x86_64'
        } else {
            return 'windows-' + targetPlatform.architecture.name
        }
    } else if (targetPlatform.operatingSystem.macOsX) {
        if (targetPlatform.architecture.amd64) {
            return 'osx-x86_64'
        } else {
            return 'osx-' + targetPlatform.architecture.name
        }
    } else {
        return targetPlatform.operatingSystem.name + '-' + targetPlatform.architecture.name
    }
}

ext.useOpenCv = { project ->
    def openCvUnzipLocation = "${project.buildDir}/opencv"

    if (project.tasks.findByPath("unzipOpenCvHeaders") == null) {
        // opencv-headers
        def openCvHeadersDependency =
            project.dependencies.create("org.opencv:opencv-headers:3.1.0@jar")
        def openCvHeadersConfig = project.configurations.detachedConfiguration(openCvHeadersDependency)
        openCvHeadersConfig.setTransitive(false)
        def openCvHeaders = openCvHeadersConfig.files[0].canonicalFile

        project.tasks.create(name: "unzipOpenCvHeaders", type: Copy) {
            description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
            group = 'OpenCv'
            from zipTree(openCvHeaders)
            into "${openCvUnzipLocation}/include"
        }
    }

    if (project.includeJava) {
        if (project.tasks.findByPath("unzipOpenCvJava") == null) {
            // opencv-java
            def openCvJavaDependency =
                project.dependencies.create("org.opencv:opencv-java:3.1.0@jar")
            def openCvJavaConfig = project.configurations.detachedConfiguration(openCvJavaDependency)
            openCvJavaConfig.setTransitive(false)
            def openCvJava = openCvJavaConfig.files[0].canonicalFile

            project.tasks.create(name: "unzipOpenCvJava", type: Copy) {
                description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
                group = 'OpenCv'
                from zipTree(openCvJava)
                into "${openCvUnzipLocation}/java"
            }
        }
    }

    project.ext.openCv = openCvUnzipLocation
    project.ext.openCvInclude = "$openCvUnzipLocation/include"

    project.ext.addOpenCvLibraryLinks = { compileTask, linker, targetPlatform ->
        def openCvPlatform = project.getOpenCvPlatformPackage(targetPlatform)

        if (project.tasks.findByPath("unzipOpenCvNatives${openCvPlatform}") == null) {
            // opencv-natives
            def openCvNativesDependency =
                project.dependencies.create("org.opencv:opencv-natives:3.1.0:${openCvPlatform}@jar")
            def openCvNativesConfig = project.configurations.detachedConfiguration(openCvNativesDependency)
            openCvNativesConfig.setTransitive(false)
            def openCvNatives = openCvNativesConfig.files[0].canonicalFile

            project.tasks.create(name: "unzipOpenCvNatives${openCvPlatform}", type: Copy) {
                description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
                group = 'OpenCv'
                from zipTree(openCvNatives)
                into "${project.openCv}/${openCvPlatform}"
            }
        }

        if (project.includeJava) {
            if (project.tasks.findByPath("unzipOpenCvJni${openCvPlatform}") == null) {
                // opencv-jni
                def openCvJniDependency =
                    project.dependencies.create("org.opencv:opencv-jni:3.1.0:${openCvPlatform}@jar")
                def openCvJniConfig = project.configurations.detachedConfiguration(openCvJniDependency)
                openCvJniConfig.setTransitive(false)
                def openCvJni = openCvJniConfig.files[0].canonicalFile

                project.tasks.create(name: "unzipOpenCvJni${openCvPlatform}", type: Copy) {
                    description = 'Unzips the OpenCV maven dependency so that the include files and libraries can be used'
                    group = 'OpenCv'
                    from zipTree(openCvJni)
                    into "${project.openCv}/${openCvPlatform}"
                }
            }
        }

        compileTask.dependsOn "unzipOpenCvHeaders", "unzipOpenCvNatives${openCvPlatform}"
        if (project.includeJava) {
            compileTask.dependsOn "unzipOpenCvJava", "unzipOpenCvJni${openCvPlatform}"
        }
        if (targetPlatform.architecture.arm) {
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_calib3d.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_core.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_features2d.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_flann.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_highgui.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_imgcodecs.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_imgproc.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_ml.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_objdetect.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_photo.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_shape.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_stitching.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_superres.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_video.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_videoio.so"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_videostab.so"
            linker.args "-ldl"
            linker.args "-lz"
        } else if (targetPlatform.operatingSystem.windows) {
            linker.args "${project.openCv}/${openCvPlatform}/opencv_core.lib"
        } else {
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_calib3d.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_core.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_features2d.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_flann.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_highgui.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_imgcodecs.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_imgproc.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_ml.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_objdetect.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_photo.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_shape.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_stitching.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_superres.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_video.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_videoio.a"
            linker.args "${project.openCv}/${openCvPlatform}/libopencv_videostab.a"
            linker.args "-ldl"
            linker.args "-lz"
        }
    }
}

ext.setupDefines = { project, binaries ->
    binaries.all {
	if (project.hasProperty('debug')) {
	    project.setupDebugDefines(cppCompiler, linker)
	} else {
	    project.setupReleaseDefines(cppCompiler, linker)
	}
        tasks.withType(CppCompile) {
            project.addWpiUtilLibraryLinks(it, linker, targetPlatform)
            project.addOpenCvLibraryLinks(it, linker, targetPlatform)
        }
    }
}

apply from: "cameraserver.gradle"

// Empty task for build so that cameraserverSourceZip will be
// built when running ./gradlew build
task build

build.dependsOn cameraserverSourceZip

apply from: 'publish.gradle'

task wrapper(type: Wrapper) {
    gradleVersion = '3.0'
}
